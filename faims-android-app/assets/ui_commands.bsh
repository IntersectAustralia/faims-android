import au.org.intersect.faims.android.data.User;
import au.org.intersect.faims.android.ui.form.EntityAttribute;
import au.org.intersect.faims.android.ui.form.RelationshipAttribute;
import java.util.List;
import java.util.Collection;
import au.org.intersect.faims.android.ui.form.NameValuePair;
import android.graphics.Color;
import com.nutiteq.projections.EPSG3857;
import com.nutiteq.components.MapPos;
import com.nutiteq.geometry.Geometry;
import com.nutiteq.geometry.Point;
import com.nutiteq.geometry.Line;
import com.nutiteq.geometry.Polygon;
import au.org.intersect.faims.android.nutiteq.GeometryStyle;
import au.org.intersect.faims.android.nutiteq.GeometryTextStyle;
import android.graphics.Typeface;
import au.org.intersect.faims.android.ui.map.QueryBuilder;
import au.org.intersect.faims.android.ui.map.LegacyQueryBuilder;
import com.nutiteq.style.PointStyle;
import com.nutiteq.style.LineStyle;
import com.nutiteq.style.PolygonStyle;
import android.app.Dialog;

//========= Persist Functionalities ==========
/**
  * Sometimes due to the nature of android destroying and restoring the project activity
  * when it runs low of resources the variable state in the ui logic can be destroyed.
  *
  * To overcome this use the following method to define the name of a single logic object
  * that will saved and restored when the activity is destroyed and restored.
  *
  * For more information on how to use this function please look at the cookbook.
  *
  * @param name the name of the object
  */
persistObject(String name) {
	linker.setPersistedObjectName(name);
}

//========= Tab / Tab Group Functionalities ==========
/**
  * Show the tab group with the following reference and clear all values in the tab group.
  *
  * @param ref the reference to the tab group
  */
newTabGroup(String ref) {
	linker.newTabGroup(ref);
}

/**
  * Show the tab with the following reference and clear all values in the tab.
  *
  * @param ref the reference to the tab
  */
newTab(String ref) {
	linker.newTab(ref);
}

/**
  * Show the tab group with the following reference.
  *
  * This will retain all the current values in the tab group.
  *
  * @param ref the reference to the tab group
  */
showTabGroup(String ref){
    linker.showTabGroup(ref);
}

/**
  * Show the tab group with the following reference and load the values of the 
  * supplied entity or relationship id into the tab group.
  *
  * @param ref the reference of the tab group
  * @param id the id of the entity or relationship
  */
showTabGroup(String ref, String id){
    linker.showTabGroup(ref, id);
}

/**
  * Show the tab with the following reference.
  *
  * This will retain all the current values in the tab.
  *
  * @param ref the reference to the tab
  */
showTab(String ref) {
	linker.showTab(ref);
}

/**
  * Show the tab with the following reference and load the values of the 
  * supplied entity or relationship id into the tab.
  *
  * @param ref the reference to the tab
  * @param id the id of the entity or relationship
  */
showTab(String ref, String id) {
	linker.showTab(ref, id);
}

/**
  * Close the tab group with the following reference with an option to show
  * a warning dialog if there are changes that haven't been saved. 
  *
  * @param ref the reference to the tab group
  * @param warn set to true to show a warning dialog if there are changes that haven't been saved
  */
cancelTabGroup(String ref, boolean warn){
	linker.cancelTabGroup(ref, warn);
}

/**
  * Close the tab with the following reference with an option to show
  * a warning dialog if there are changes that haven't been saved. 
  *
  * @param ref the reference to the tab
  * @param warn set to true to show a warning dialog if there are changes that haven't been saved
  */
cancelTab(String ref, boolean warn){
	linker.cancelTab(ref, warn);
}

//========= Dialog Functionalities ==========
/**
  * Show a toast to the user with the given message, the toast will last for about 1 second.
  *
  * @param message the message to be shown to the user
  */
showToast(String message) {
    linker.showToast(message);
}

/**
  * Show an alert dialog to the user with the given message.
  *
  * @param title the title of the dialog
  * @param message the message to be shown to the user
  * @param okCallback the callback that is executed when Ok button is pressed
  * @param cancelCallback the callback that is executed when Cancel button is pressed
  */
showAlert(String title, String message, String okCallback, String cancelCallback){
    linker.showAlert(title, message, okCallback, cancelCallback);
}

/**
  * Show a warning dialog to the user with the given message.
  *
  * @param title the title of the dialog
  * @param message the message to be shown to the user
  */
showWarning(String title, String message) {
	linker.showWarning(title, message);
}

/**
  * Show a busy dialog to the user with the given message.
  *
  * @param title the title of the dialog
  * @param message the message to be shown to the user
  */
showBusy(String title, String message) {
	return linker.showBusy(title, message);
}

//========= Setter / Getter Functionalities ==========
/**
  * Set the field with the following reference with the given value.
  *
  * If the field reference is not found a logic error dialog will appear.
  *
  * For more information on how to use this function please look at the cookbook.
  *
  * @param ref the reference to the field
  * @param value the value to set the field to
  */
setFieldValue(String ref, Object value){
    linker.setFieldValue(ref, value);
}

/**
  * Set the field with the following reference with the given certainty
  *
  * If the field reference is not found a logic error dialog will appear.
  *
  * @param ref the reference to the field
  * @param value the value to set the certainty for the field to
  */
setFieldCertainty(String ref, Object value){
    linker.setFieldCertainty(ref, value);
}

/**
  * Set annotation to the field that has the reference with given value. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param value the value to be set to the field, only accept String
  */
setFieldAnnotation(String ref, Object value){
    linker.setFieldAnnotation(ref, value);
}

/**
  * Get value of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the value of the field, could be collection or String
  */
Object getFieldValue(String ref){
    return linker.getFieldValue(ref);
}

/**
  * Get certainty of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the certainty of the field in String representation
  */
Object getFieldCertainty(String ref){
    return linker.getFieldCertainty(ref);
}

/**
  * Get annotation of the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @return the annotation of the field in String representation
  */
Object getFieldAnnotation(String ref){
    return linker.getFieldAnnotation(ref);
}

/**
  * Get the current time of the application
  * @return the current time in String representation
  */
String getCurrentTime(){
    return linker.getCurrentTime();
}

/**
  * Clear the dirty button from the field that has the reference. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  */
clearFieldDirty(String ref) {
	linker.setFieldDirty(ref, false, "");
}

//========= Event Callback Functionalities ==========
/**
  * Binding an event to the field that has the reference with a callback. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param type the type of event, one of click, show, or load
  * @param callback the callback that is executed when the binded field is on the set event
  */
onEvent(String ref, String type, String callback) {
	linker.bindViewToEvent(ref, type, callback);
}

/**
  * Binding a focus/blur event to the field that has the reference with a callback. If the field reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param focusCallback the callback that is executed when the field is on focus event
  * @param blurCallback the callback that is executed when the field is on blur event
  */
onFocus(String ref, String focusCallback, String blurCallback) {
	linker.bindFocusAndBlurEvent(ref, focusCallback, blurCallback);
}

//========= User Functionalities ==========
/**
  * Set the current user of the application, used to determine who creates the record.
  * @param user the user of the application
  */
setUser(User user){
	linker.setUser(user);
}

//========= Arch Ent / Relationship Functionalities ==========
/**
  * Saving arch entity into the database and return the entity_id of the saved entity
  * @param entity_id the id of the arch entity to be saved, might be null to save new entity
  * @param entity_type the type of the entity to be saved, must be coherent with the type specified in data schema
  * @param geo_data the list of geometries to be associated with the saved entity
  * @param attributes the list of attributes to be associated with the saved entity
  * @return the entity_id of the saved entity
  */
saveArchEnt(String entity_id, String entity_type, List geo_data, List attributes) {
	return linker.saveArchEnt(entity_id, entity_type, geo_data, attributes);
}

/**
  * Saving relationship into the database and return the rel_id of the saved relationship
  * @param rel_id the id of the relationship to be saved, might be null to save new relationship
  * @param rel_type the type of the relationship to be saved, must be coherent with the type specified in data schema
  * @param geo_data the list of geometries to be associated with the saved relationship
  * @param attributes the list of attributes to be associated with the saved relationship
  * @return the rel_id of the saved relationship
  */
saveRel(String rel_id, String rel_type, List geo_data, List attributes) {
	return linker.saveRel(rel_id, rel_type, geo_data, attributes);
}

/**
  * Delete an arch entity from the database
  * @param entity_id the id of the arch entity to be deleted
  * @return boolean value true if deleted, false if not
  */
deleteArchEnt(String entity_id){
	return linker.deleteArchEnt(entity_id);
}

/**
  * Delete a relationship from the database
  * @param rel_id the id of the relationship to be deleted
  * @return boolean value true if deleted, false if not
  */
deleteRel(String rel_id){
	return linker.deleteRel(rel_id);
}

/**
  * Add an arch entity to the relationship by specifying the verb as the relation.
  * @param entity_id the id of the arch entity to be associated with relationship
  * @param rel_id the id of the relationship to be associated to
  * @param verb the relation that is defined in the dataschema
  */
addReln(String entity_id, String rel_id, String verb) {
	linker.addReln(entity_id, rel_id, verb);
}

/**
  * Create attribute list to be saved to the entity/relationship
  * @return new attribute list
  */
createAttributeList() {
	return new ArrayList();
}

/**
  * Create entity attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the entity attribute, could be null
  * @param vocab the vocab of the entity attribute (obtained from the database), could be null
  * @param measure the measure of the entity attribute, could be null
  * @param certainty the certainty of the entity attribute, defaulted to 100% certainty
  * @return EntityAttribute
  */
createEntityAttribute(String name, String text, String vocab, String measure, String certainty){
	return createEntityAttribute(name, text, vocab, measure, certainty, false);
}

/**
  * Create entity attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the entity attribute, could be null
  * @param vocab the vocab of the entity attribute (obtained from the database), could be null
  * @param measure the measure of the entity attribute, could be null
  * @param certainty the certainty of the entity attribute, defaulted to 100% certainty
  * @param isDeleted set whether the entity attribute is deleted or not
  * @return EntityAttribute
  */
createEntityAttribute(String name, String text, String vocab, String measure, String certainty, boolean isDeleted) {
	EntityAttribute attribute = new EntityAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	attribute.setMeasure(measure);
	attribute.setCertainty(certainty);
	attribute.setDeleted(isDeleted);
	return attribute;
}

/**
  * Create relationship attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the relationship attribute, could be null
  * @param vocab the vocab of the relationship attribute (obtained from the database), could be null
  * @param certainty the certainty of the relationship attribute, defaulted to 100% certainty
  * @return RelationshipAttribute
  */
createRelationshipAttribute(String name, String text, String vocab, String certainty){
	return createRelationshipAttribute(name, text, vocab, certainty, false);
}

/**
  * Create relationship attribute to be added to the attribute list
  * @param name the name of the attribute, should be coherent to the attribute name specified in the schema to be saved
  * @param text the text of the relationship attribute, could be null
  * @param vocab the vocab of the relationship attribute (obtained from the database), could be null
  * @param certainty the certainty of the relationship attribute, defaulted to 100% certainty
  * @param isDeleted set whether the relationship attribute is deleted or not
  * @return RelationshipAttribute
  */
createRelationshipAttribute(String name, String text, String vocab, String certainty, boolean isDeleted) {
	RelationshipAttribute attribute = new RelationshipAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	attribute.setCertainty(certainty);
	attribute.setDeleted(isDeleted);
	return attribute;
}

/**
  * Populate dropdown from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the dropdown
  */
populateDropDown(String ref, Collection values){
    linker.populateDropDown(ref, values);
}

/**
  * Populate radio group from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the radio group
  */
populateRadioGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

/**
  * Populate checkbox from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the checkbox
  */
populateCheckBoxGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

/**
  * Populate list from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the list
  */
populateList(String ref, Collection values){
	linker.populateList(ref, values);
}

/**
  * Populate picture gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing.
  * @param ref the reference to the field
  * @param values the collection of values to populate the picture gallery
  */
populatePictureGallery(String ref, Collection values){
	linker.populatePictureGallery(ref, values);
}

/**
  * Populate camera picture gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show picture\n
  * after taking picture from camera.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateCameraPictureGallery(String ref, Collection values){
	linker.populateCameraPictureGallery(ref, values);
}

/**
  * Populate video gallery from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show video\n
  * after recording video.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateVideoGallery(String ref, Collection values){
	linker.populateVideoGallery(ref, values);
}

/**
  * Populate audio list from values to the field that has the reference. If the field reference is not found\n
  * or wrong type of field, there will be a logic error dialog appearing. This is usually used to show audio\n
  * after recording audio.
  * @param ref the reference to the field
  * @param values the collection of values to populate the camera picture gallery
  */
populateAudioList(String ref, Collection values){
	linker.populateAudioList(ref, values);
}

/**
  * Fetching the data of arch entity with the given id, if the id is not found, a logic error dialog will appear
  * @param id the entity id of the arch entity
  * @return ArchEntity object or null
  */
Object fetchArchEnt(String id){
    return linker.fetchArchEnt(id);
}

/**
  * Fetching the data of relationship with the given id, if the id is not found, a logic error dialog will appear
  * @param id the entity id of the relationship
  * @return Relationship object or null
  */
Object fetchRel(String id){
    return linker.fetchRel(id);
}

/**
  * Fetching the data from the database by running query specified by user. It will only return one result.
  * @param query the query to be run against the database
  * @return Collection of String, might be empty
  */
Object fetchOne(String query){
    return linker.fetchOne(query);
}

/**
  * Fetching the data from the database by running query specified by user. It will return all result.
  * @param query the query to be run against the database
  * @return Collection of Collection of String, might be empty
  */
Collection fetchAll(String query){
    return linker.fetchAll(query);
}

/**
  * Fetching the list of arch entity to show to the user so the user can see what entities have been saved.
  * @param type the type of arch entity to be shown
  * @return Collection of Collection of String, might be empty
  */
Collection fetchEntityList(String type){
    return linker.fetchEntityList(type);
}

/**
  * Fetching the list of relationship to show to the user so the user can see what entities have been saved.
  * @param type the type of relationship to be shown
  * @return Collection of Collection of String, might be empty
  */
Collection fetchRelationshipList(String type){
    return linker.fetchRelationshipList(type);
}

/**
  * Get the selected value from the list to be used in the logic
  * @return _list_item_value of the selected value in the list
  */
String getListItemValue() {
	return _list_item_value;
}

//========= Navigation Functionalities ==========
/**
  * Provide functionality to go back as if the user press the hardware back button
  */
goBack(){
	linker.goBack();
}

//========= GPS Functionalities ==========
/**
  * Set the GPS update interval to determine how often the GPS should update, defaulted to 10 seconds
  * @param seconds the interval to be set
  */
setGPSUpdateInterval(int seconds){
	linker.setGpsUpdateInterval(seconds);
}

/**
  * Start using the internal GPS to update the location
  */
startInternalGPS(){
	linker.startInternalGPS();
}

/**
  * Start using the external GPS to update the location, it will bring up dialog to the user to choose\n
  * which bluetooth device to be used as external GPS
  */
startExternalGPS(){
	linker.startExternalGPS();
}

/**
  * Get the GPS position containing longitude and latitude from external GPS or internal GPS
  * @return GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPosition(){
	return linker.getGPSPosition();
}

/**
  * Get the GPS position containing longitude and latitude with the projection selected from external GPS or internal GPS
  * @return projected GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPositionProjected() {
	return linker.getGPSPositionProjected();
}

/**
  * Get the GPS accuracy from external GPS or internal GPS
  * @return accuracy of the gps or null
  */
Object getGPSEstimatedAccuracy(){
	return linker.getGPSEstimatedAccuracy();
}

/**
  * Get the GPS heading from external GPS or internal GPS
  * @return heading of the gps or null
  */
Object getGPSHeading(){
	return linker.getGPSHeading();
}

/**
  * Get the GPS position containing longitude and latitude from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return GPSPosition if starting GPS or null if no GPS started or position found
  */
Object getGPSPosition(String gps){
	return linker.getGPSPosition(gps);
}

/**
  * Get the GPS accuracy from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return accuracy of the selected gps or null
  */
Object getGPSEstimatedAccuracy(String gps){
	return linker.getGPSEstimatedAccuracy(gps);
}

/**
  * Get the GPS heading from selected GPS
  * @param gps the type of gps used, one of "internal" or "external"
  * @return heading of the selected gps or null
  */
Object getGPSHeading(String gps){
	return linker.getGPSHeading(gps);
}

/**
  * Start track log of the GPS and save it to the database so the user can look at the track log in the map view
  * @param type either "distance" or "time"
  * @param value the value of the tracking, if type is "distance", the value will be in meter, if type is "time", the value will be in seconds
  * @param callback code to execute when interval limit is reached
  */
startTrackingGPS(String type, int value, String callback){
	linker.startTrackingGPS(type, value, callback);
}

/**
  * Stopping the track log of the GPS
  */
stopTrackingGPS(){
	linker.stopTrackingGPS();
}

//========= Map Functionalities ==========
/**
  * Binding map click event and vector click event to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param clickCallback the call back that is executed when the map view is clicked
  * @param selectCallback the call back that is executed when the vector element is clicked
  */
onMapEvent(String ref, String clickCallback, selectCallback) {
	linker.bindMapEvent(ref, clickCallback, selectCallback);
}

/**
  * Show base map to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing. the map view will be the base map.
  * @param ref the reference to the map view
  * @param layerName the layer name for the raster map
  * @param filename the filename of the map view, will show error if the file does not exist
  */
showBaseMap(String ref, String layerName, String filename) {
	linker.showBaseMap(ref, layerName, filename);
}

/**
  * Show raster map to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing. You have include multiple raster maps.
  * @param ref the reference to the map view
  * @param layerName the layer name for the raster map
  * @param filename the filename of the map view, will show error if the file does not exist
  */
showRasterMap(String ref, String layerName, String filename) {
	linker.showRasterMap(ref, layerName, filename);
}

/**
  * Set the focus point of the map view that has the reference by specifying the float value of longitude and latitude.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param longitude the longitude of the focus point
  * @param latitude the latitude of the focus point
  */
setMapFocusPoint(String ref, float longitude, float latitude) {
	linker.setMapFocusPoint(ref, longitude, latitude);
}

/**
  * Set the focus point of the map view that has the reference by specifying the double value of longitude and latitude.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param longitude the longitude of the focus point
  * @param latitude the latitude of the focus point
  */
setMapFocusPoint(String ref, double longitude, double latitude) {
	setMapFocusPoint(ref, (float) longitude, (float) latitude);
}

/**
  * Set the rotation of the map view that has the reference by specifying the rotation value.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param rotation the rotation of the map view in degrees
  */
setMapRotation(String ref, float rotation) {
	linker.setMapRotation(ref, rotation);
}

/**
  * Set the zoom level of the map view that has the reference by specifying the zoom value.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param zoom the zoom value of the map view
  */
setMapZoom(String ref, float zoom) {
	linker.setMapZoom(ref, zoom);
}

/**
  * Set the perspective view of the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param tilt the tilt value default is 90 degrees for 2d view, minimum is 30 degrees
  */
setMapTilt(String ref, float tilt) {
	linker.setMapTilt(ref, tilt);
}

/**
  * Show a shape layer to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerName the layer name for the shape layer
  * @param filename the file path of the shape map, will show error if the file does not exist
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  */
showShapeLayer(String ref, String layerName, String filename, GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle) {
	linker.showShapeLayer(ref, layerName, filename, pointStyle, lineStyle, polygonStyle);
}

/**
  * Show a spatial layer to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerName the layer name for the shape layer
  * @param filename the file path of the shape map, will show error if the file does not exist
  * @param tableName the table name to be loaded from the database
  * @param idColumn the id column from the table to be loaded from the database
  * @param labelColumn the label column from the table to be loaded from the database to be shown as the label
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  * @param textStyle the styling to all text labels appearing in the layer
  */
showSpatialLayer(String ref, String layerName, String filename, String tableName, String idColumn, String labelColumn, GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle, GeometryTextStyle textStyle) {
	linker.showSpatialLayer(ref, layerName, filename, tableName, idColumn, labelColumn, pointStyle, lineStyle, polygonStyle, textStyle);
}

/**
  * Show a database layer to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing. The layer shows all saved geometries in the database.
  * @param ref the reference to the map view
  * @param layerName the layer name for the shape layer
  * @param isEntity a boolean value to determine whether it is entity or relationship
  * @param queryName the query name for the executed query
  * @param querySql the sql to be executed for the layer
  * @param pointStyle the styling to points appearing in the layer
  * @param lineStyle the styling to lines appearing in the layer
  * @param polygonStyle the styling to polygons appearing in the layer
  * @param textStyle the styling to all text labels appearing in the layer
  */
showDatabaseLayer(String ref, String layerName, boolean isEntity, String queryName, String querySql,GeometryStyle pointStyle, GeometryStyle lineStyle, GeometryStyle polygonStyle, GeometryTextStyle textStyle) {
	linker.showDatabaseLayer(ref, layerName, isEntity, queryName, querySql, pointStyle, lineStyle, polygonStyle, textStyle);
}

/**
  * Remove a layer from the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerid to be removed, if not found, a logic error will appear.
  */
removeLayer(String ref, int layerId) {
	linker.removeLayer(ref, layerId);
}

/**
  * Centering the map view that has the reference based on the current GPS position if there is GPS position.
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  */
centerOnCurrentPosition(String ref){
	linker.centerOnCurrentPosition(ref);
}

/**
  * Create canvas layer and add it to the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerName the name of the canvas layer
  */
createCanvasLayer(String ref, String layerName) {
	return linker.createCanvasLayer(ref, layerName);
}

/**
  * Set the visibility of a layer in the map view that has the reference. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to set visibility, will show logic error dialog if not found
  * @param visible the boolean to set whether it is visible or not
  */
setLayerVisible(String ref, int layerId, boolean visible) {
	linker.setLayerVisible(ref, layerId, visible);
}

/**
  * Get the clicked position in the map view
  * @return the clicked map point
  */
getMapPointClicked() {
	return _map_point_clicked;
}

/**
  * Draw a point on the map view that has the reference by specifying the point and style. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to draw the point to, will show logic error dialog if not found
  * @param point the map view point to be drawn
  * @param style the style that will be applied to the point
  */
drawPoint(String ref, int layerId, MapPos point, GeometryStyle style) {
	linker.drawPoint(ref, layerId, point, style);
}

/**
  * Draw a line on the map view that has the reference by specifying the points and style. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to draw the point to, will show logic error dialog if not found
  * @param points the map view points to be drawn as a line
  * @param style the style that will be applied to the line
  */
drawLine(String ref, int layerId, List points, GeometryStyle style) {
	linker.drawLine(ref, layerId, points, style);
}

/**
  * Draw a polygon on the map view that has the reference by specifying the points and style. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to draw the point to, will show logic error dialog if not found
  * @param points the map view points to be drawn as polygon
  * @param style the style that will be applied to the polygon
  */
drawPolygon(String ref, int layerId, List points, GeometryStyle style) {
	linker.drawPolygon(ref, layerId, points, style);
}

/**
  * Clear a geometry from the map view that has the reference by specifying the geometry id. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param geomId the id of the geometry to be cleared, will show logic error dialog if not found
  */
clearGeometry(String ref, int geomId) {
	linker.clearGeometry(ref, geomId);
}

/**
  * Clear a list of geometries from the map view that has the reference by specifying the list of geometry.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param geomList the list of id of the geometries to be cleared, will show logic error dialog if not found
  */
clearGeometryList(String ref, List geomList) {
	linker.clearGeometryList(ref, geomList);
}

/**
  * Create a point from string longitude and string latitude
  * @param lon the longitude of the point in String format
  * @param lat the latitude of the point in String format
  * @return MapPos the new point object for the map view
  */
createPoint(String lon, String lat) {
	return createPoint(Float.parseFloat(lon), Float.parseFloat(lat));
}

/**
  * Create a point from float longitude and float latitude
  * @param lon the longitude of the point in float format
  * @param lat the latitude of the point in float format
  * @return MapPos the new point object for the map view
  */
createPoint(float lon, float lat) {
	return new MapPos(lon, lat);
}

/**
  * Create a point from double longitude and double latitude
  * @param lon the longitude of the point in double format
  * @param lat the latitude of the point in double format
  * @return MapPos the new point object for the map view
  */
createPoint(double lon, double lat) {
	return createPoint((float) lon, (float) lat);
}

/**
  * Get all geometries in a specified layer from the map view that has the reference.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to get the geometries from, will show logic error dialog if not found
  * @return list of the geometries or null
  */
getGeometryList(String ref, int layerId) {
	return linker.getGeometryList(ref, layerId);
}

/**
  * Get a geometry from the map view that has the reference by specifying the geometry id.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param geomId the id of the geometry, will show logic error dialog if not found
  * @return list of the geometries or null
  */
getGeometry(String ref, int geomId) {
	return linker.getGeometry(ref, geomId);
}

/** 
  * Get the layer name of the associated geometry on a canvas layer
  * @param ref the reference to the map view
  * @geomId the id of the geometry
  * @return the layer name of the canvas layer the geometry is on
  */
getGeometryLayerName(String ref, int geomId) {
	return linker.getGeometryLayerName(ref, geomId);
}

/**
  * Draw geometry on the map view that has the reference by specifying the geometry and style. If the map view reference is not found,\n
  * there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param layerId the layerId to draw the geometry to, will show logic error dialog if not found
  * @param geom the geometry to be drawn
  * @param style the style that will be applied to the geometry
  * @return the id of the created geometry
  */
drawGeometry(String ref, int layerId, Geometry geom, GeometryStyle style) {
	if (geom instanceof Point) {
		return drawPoint(ref, layerId, ((Point) geom).getMapPos(), style);
	} else if (geom instanceof Line) {
		return drawLine(ref, layerId, ((Line) geom).getVertexList(), style);
	} else if (geom instanceof Polygon) {
		return drawPolygon(ref, layerId, ((Polygon) geom).getVertexList(), style);
	}
}

/**
  * Create styling for point by specifying the minZoom, color, size, and pickSize
  * @param minZoom the minimum level of zoom for the point to show up
  * @param color the color of the point
  * @param size the size of the point, range from 0.0 - 1.0
  * @param pickSize the picking size of the point, used for selecting the point, range from 0.0 - 1.0
  * @return the new point style
  */
createPointStyle(int minZoom, int color, float size, float pickSize) {
	return linker.createPointStyle(minZoom, color, size, pickSize);
}

/**
  * Create styling for line by specifying the minZoom, color, width, pickWidth, and pointStyle
  * @param minZoom the minimum level of zoom for the line to show up
  * @param color the color of the line
  * @param width the width of the line, range from 0.0 - 1.0
  * @param pickWidth the picking width of the line, used for selecting the line, range from 0.0 - 1.0
  * @param pointStyle the styling of the point for the line
  * @return the new line style
  */
createLineStyle(int minZoom, int color, float width, float pickWidth, GeometryStyle pointStyle) {
	return linker.createLineStyle(minZoom, color, width, pickWidth, pointStyle);
}

/**
  * Create styling for polygon by specifying the minZoom, color, and lineStyle
  * @param minZoom the minimum level of zoom for the polygon to show up
  * @param color the color of the polygon
  * @param lineStyle the styling of the line for the polygon
  * @return the new polygon style
  */
createPolygonStyle(int minZoom, int color, GeometryStyle lineStyle) {
	return linker.createPolygonStyle(minZoom, color, lineStyle);
}

/**
  * Create styling for text label by specifying the minZoom, color, size, and font
  * @param minZoom the minimum level of zoom for the text label to show up
  * @param color the color of the text label
  * @param size the size of the text label
  * @param font the font of the text label
  * @return the new text style
  */
createTextStyle(int minZoom, int color, int size, android.graphics.Typeface font) {
	return linker.createTextStyle(minZoom, color, size, font);
}

/**
  * Unlock or locking the map view has the reference from moving, useful when editing geometries.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param lock boolean value to set locking or unlocking
  */
lockMapView(String ref, boolean lock) {
	linker.lockMapView(ref, lock);
}

/**
  * Adding a geometry to the higlighted geometries list to the map view has the reference.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param geomId the id of the geometry to be highlighted
  */
addGeometryHighlight(String ref, int geomId) {
	linker.addGeometryHighlight(ref, geomId);
}

/**
  * Removing a geometry from the higlighted geometries list to the map view has the reference.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param geomId the id of the geometry to be removed from highlighted list
  */
removeGeometryHighlight(String ref, int geomId) {
	linker.removeGeometryHighlight(ref, geomId);
}

/**
  * This locks highlights in place so that when doHighlightTransform is called
  * the highlighted geometry will be transformed to their new location
  * @param ref the reference to the map view
  */
prepareHighlightTransform(String ref) {
	linker.prepareHighlightTransform(ref);
}

/**
  * This unlocks highlights so that geometries that were locked using prepareHighlightTransform
  * get transformed to their new position, rotation and scaling
  * @param ref the reference to the map view
  */
doHighlightTransform(String ref) {
	linker.doHighlightTransform(ref);
}

/**
  * Clearing all higlighted geometries list from the map view has the reference.
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  */
clearGeometryHighlights(String ref) {
	linker.clearGeometryHighlights(ref);
}

/**
  * Get all higlighted geometries list from the map view has the reference.
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  */
getGeometryHighlights(String ref) {
	return linker.getGeometryHighlights(ref);
}

/**
  * Get the selected geometry on the map view
  * @return the selected geometry
  */
getMapGeometrySelected() {
	return _map_geometry_selected;
}

/**
  * Adding a database layer query to the map view has the reference to show the saved geometries in the database.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param name the name of the query added
  * @param sql the query to be executed when selected
  */
addDatabaseLayerQuery(String ref, String name, String sql) {
	linker.addDatabaseLayerQuery(ref, name, sql);
}

/**
  * Adding a tracklog layer query to the map view has the reference to show the GPS tracking for all users.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.
  * @param ref the reference to the map view
  * @param name the name of the query added
  * @param sql the query to be executed when selected
  */
addTrackLogLayerQuery(String ref, String name, String sql) {
	linker.addTrackLogLayerQuery(ref, name, sql);
}

/**
  * Adding a query builder to the map view has the reference to select geometries based on the query.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.\n
  * The selection will only select the geometries in the database layer.
  * @param ref the reference to the map view
  * @param name the name of the query added
  * @param builder the query builder to be executed when selected
  */
addSelectQueryBuilder(String ref, String name, QueryBuilder builder) {
	linker.addSelectQueryBuilder(ref, name, builder);
}

/**
  * Create a query builder for database select by providing the sql query
  * @param sql the query to be executed when selected
  */
createQueryBuilder(String sql) {
	return new QueryBuilder(sql);
}

/**
  * Adding a query builder to the map view has the reference to select geometries based on the query.\n
  * If the map view reference is not found, there will be a logic error dialog appearing.\n
  * The selection will only select the geometries in the legacy layer.
  * @param ref the reference to the map view
  * @param name the name of the query added
  * @param dbPath the path of the database file
  * @param tableName the name of the table for the database executed against
  * @param builder the query builder to be executed when selected
  */
addLegacySelectQueryBuilder(String ref, String name, String dbPath, String tableName, QueryBuilder builder) {
	linker.addLegacySelectQueryBuilder(ref, name, dbPath, tableName, builder);
}

/**
  * Create a legacy query builder for legacy select by providing the sql query
  * @param sql the query to be executed when selected
  */
createLegacyQueryBuilder(String sql) {
	return new LegacyQueryBuilder(sql);
}

/**
  * Convert a map position from one projection to another projection
  * @param fromSrid the projection to convert
  * @param toSrid the projection to be converted to
  * @param p the map position to be converted
  */
convertFromProjToProj(String fromSrid, String toSrid, MapPos p) {
	return linker.convertFromProjToProj(fromSrid, toSrid, p);
}

/**
  * Enable or disable map tools for the map view
  * @param ref the reference to the map view
  * @param enabled true or false to enable or disable map tools
  */
setToolsEnabled(String ref, boolean enabled) {
	linker.setToolsEnabled(ref, enabled);
}

/** 
  * Add tool specific events (create or load). 
  * The create event is called when the create point, line or polygon
  * tools generate their geometry
  * The load event is called when the load data tool is used to select
  * geometry
  * @param ref the reference to the map view
  * @param type the event type (create or load)
  * @callback the callback code to execute
  */ 
onToolEvent(String ref, String type, String callback) {
	linker.bindToolEvent(ref, type, callback);
}

/**
  * This used with the tool creat event callback to get the created geometry id
  */
getMapGeometryCreated() {
	return _map_geometry_created;
}

/**
  * This used with the tool load event callback to get the uuid of the selected geometry
  */
getMapGeometryLoaded() {
	return _map_geometry_loaded;
}

/**
  * This used with the tool load event callback to get the type (entity or relationship) of the selected geometry
  */
getMapGeometryLoadedType() {
	return _map_geometry_loaded_type;
}

/**
  * This refreshes the map layers. Useful if you have saved entities or relationships into the
  * database and want to update the map layers.
  * @param reference to the map view
  */
refreshMap(String ref) {
	linker.refreshMap(ref);
}

//========= Sync Functionalities ==========
/**
  * Pushing a database to the server which is used for syncing, after finished, it will execute the callback
  * @param callback the callback that will be executed when the operation finished
  */
pushDatabaseToServer(String callback) {
	linker.pushDatabaseToServer(callback);
}

/**
  * Pulling a database from the server which is used for syncing, after finished, it will execute the callback
  * @param callback the callback that will be executed when the operation finished
  */
pullDatabaseFromServer(String callback) {
	linker.pullDatabaseFromServer(callback);
}

/**
  * Set whether the sync should be enabled or not
  * @param value boolean value to set the sync enabled or not
  */
setSyncEnabled(boolean value) {
	linker.setSyncEnabled(value);
}

/**
  * An event listener for sync that will execute call back for start, success, and failure of the sync
  * @param startCallback the callback that will be executed when sync is started
  * @param successCallback the callback that will be executed when sync is finish
  * @param failureCallback the callback that will be executed when sync is failing
  */
onSyncEvent(String startCallback, String successCallback, String failureCallback) {
	linker.addSyncListener(startCallback, successCallback, failureCallback);
}

/**
  * Set the minimum interval for the sync to happen
  * @param value the minimum interval for the sync to happen
  */
setSyncMinInterval(float value) {
	linker.setSyncMinInterval(value);
}

/**
  * Set the maximum interval for the sync to happen
  * @param value the maximum interval for the sync to happen
  */
setSyncMaxInterval(float value) {
	linker.setSyncMaxInterval(value);
}

/**
  * Set the delay interval for each sync
  * @param value the delay interval for each sync
  */
setSyncDelay(float value) {
	linker.setSyncDelay(value);
}

/**
  * Set whether the file sync should be enabled or not
  * @param value boolean value to set the file sync enabled or not
  */
setFileSyncEnabled(boolean enabled) {
	linker.setFileSyncEnabled(enabled);
}

//========= Static Data Functionalities ==========
/**
  * Get the static data for current project name
  * @return project name
  */
String getProjectName(){
	return linker.getProjectName();
}

/**
  * Get the static data for current project projection
  * @return project projection
  */
String getProjectSrid(){
	return linker.getProjectSrid();
}

/**
  * Get the static data for current project id
  * @return project id
  */
String getProjectId(){
	return linker.getProjectId();
}

/**
  * Get the static data for current project season
  * @return project season
  */
String getProjectSeason(){
	return linker.getProjectSeason();
}

/**
  * Get the static data for current project description
  * @return project description
  */
String getProjectDescription(){
	return linker.getProjectDescription();
}

/**
  * Get the static data for current permit number
  * @return permit number
  */
String getPermitNo(){
	return linker.getPermitNo();
}

/**
  * Get the static data for current permit holder
  * @return permit holder
  */
String getPermitHolder(){
	return linker.getPermitHolder();
}

/**
  * Get the static data for current contact and address
  * @return contact and address
  */
String getContactAndAddress(){
	return linker.getContactAndAddress();
}

/**
  * Get the static data for current participants
  * @return participants
  */
String getParticipants(){
	return linker.getParticipants();
}

/**
  * Get the static data for permit issued by
  * @return permit issued by
  */
public String getPermitIssuedBy() {
	return linker.getPermitIssuedBy();
}

/**
  * Get the static data for permit type
  * @return permit type
  */
public String getPermitType() {
	return linker.getPermitType();
}

/**
  * Get the static data for copyright holder
  * @return copyright holder
  */
public String getCopyrightHolder() {
	return linker.getCopyrightHolder();
}

/**
  * Get the static data for client/sponsor
  * @return client/sponsor
  */
public String getClientSponsor() {
	return linker.getClientSponsor();
}

/**
  * Get the static data for land owner
  * @return land owner
  */
public String getLandOwner() {
	return linker.getLandOwner();
}

/**
  * Get the static data for whether containing sensitive data or not
  * @return true or false
  */
public String hasSensitiveData() {
	return linker.hasSensitiveData();
}

//========= File attachment Functionalities ==========
/**
  * Get the name of last selected file from the file browser
  * @return name of last selected file
  */
getLastSelectedFilename() {
	return _last_selected_filename;
}

/**
  * Get the path of last selected file from the file browser
  * @return path of last selected file
  */
getLastSelectedFilepath() {
	return _last_selected_filepath;
}

/**
  * Show the file browser and execute the callback after finish
  * @param callback the callback to be executed once the operation finished
  */
showFileBrowser(String callback) {
	linker.showFileBrowser(callback);
}

/**
  * Attach a file to the project folder by specifying the path of the file.If sync is true,\n
  * the file will be available on the other devices syncing to the server. If not, the file\n
  * will only available on the server.
  * @param filepath the path of the file to be synced
  * @param sync the boolean value to tell whether the file should be copied to the app/server folder
  */
attachFile(String filePath, boolean sync) {
	return linker.attachFile(filePath, sync, null, null);
}

/**
  * Attach a file to the project folder by specifying the path of the file.If sync is true,\n
  * the file will be available on the other devices syncing to the server. If not, the file\n
  * will only available on the server. If the dir is defined, it will create the dir in the app/server folder.
  * @param filepath the path of the file to be synced
  * @param sync the boolean value to tell whether the file should be copied to the app/server folder
  * @param dir the directory to be added to the app/server folfer, might be null
  */
attachFile(String filePath, boolean sync, String dir) {
	return linker.attachFile(filePath, sync, dir, null);
}

/**
  * Attach a file to the project folder by specifying the path of the file.If sync is true,\n
  * the file will be available on the other devices syncing to the server. If not, the file\n
  * will only available on the server. If the dir is defined, it will create the dir in the app/server folder.
  * @param filepath the path of the file to be synced
  * @param sync the boolean value to tell whether the file should be copied to the app/server folder
  * @param dir the directory to be added to the app/server folfer, might be null
  * @param callback code to execute when file is finish copying into files directory
  */
attachFile(String filePath, boolean sync, String dir, String callback) {
	return linker.attachFile(filePath, sync, dir, callback);
}

/**
  * List all attached file to an arch entity by providing the id of the arch entity.
  * @param id the id of the arch entity, it will get the logic error dialog if null
  */
viewArchEntAttachedFiles(String id){
	linker.viewArchEntAttachedFiles(id);
}

/**
  * List all attached file to an arch entity by providing the id of the relationship.
  * @param id the id of the relationship, it will get the logic error dialog if null
  */
viewRelAttachedFiles(String id){
	linker.viewRelAttachedFiles(id);
}

/**
  * Open the camera and then execute the callback after finish
  * @param callback the callback executed after operation is finish
  */
openCamera(String callback){
	linker.openCamera(callback);
}

/**
  * Open the video recorder and then execute the callback after finish
  * @param callback the callback executed after operation is finish
  */
openVideo(String callback){
	linker.openVideo(callback);
}

/**
  * Open the audio recorder and then execute the callback after finish
  * @param callback the callback executed after operation is finish
  */
recordAudio(String callback){
	linker.recordAudio(callback);
}

/**
  * Get the path of last taken picture
  * @return the path of the last taken picture
  */
String getLastPictureFilePath(){
	return linker.getLastPictureFilePath();
}

/**
  * Get the path of last recorded video
  * @return the path of the last recorded video
  */
String getLastVideoFilePath(){
	return linker.getLastVideoFilePath();
}

/**
  * Get the path of last recorded audio
  * @return the path of the last recorded audio
  */
String getLastAudioFilePath(){
	return linker.getLastAudioFilePath();
}

/**
  * @return returns true if files are currently being attached
  */
isAttachingFiles(){
	return linker.isAttachingFiles();
}

/**
  * @return returns the full path to attached file
  */
getAttachedFilePath(String file) {
	return linker.getAttachedFilePath(file);
}

/**
  * @return returns the full path to attached file
  */
stripAttachedFilePath(String file) {
	return linker.stripAttachedFilePath(file);
}

//========= MISC ==========

/**
  * Executes a given string of code
  * @param code the string of code to execute
  */
execute(String code){
	return linker.execute(code);
}