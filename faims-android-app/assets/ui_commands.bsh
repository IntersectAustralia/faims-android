import au.org.intersect.faims.android.ui.form.EntityAttribute;
import au.org.intersect.faims.android.ui.form.RelationshipAttribute;
import java.util.List;
import java.util.Collection;
import au.org.intersect.faims.android.ui.form.NameValuePair;

newTabGroup(String label) {
	linker.newTabGroup(label);
}

newTab(String label) {
	linker.newTab(label);
}

showTabGroup(String label){
    linker.showTabGroup(label);
}

showTabGroup(String id, String uuid){
    linker.showTabGroup(id,uuid);
}

showTab(String label) {
	linker.showTab(label);
}

showTab(String id, String uuid) {
	linker.showTab(id, uuid);
}

cancelTab(String id, boolean warn){
	linker.cancelTab(id,warn);
}

showToast(String message) {
    linker.showToast(message);
}

showAlert(String title, String message, String okCallback, String cancelCallback){
    linker.showAlert(title, message, okCallback, cancelCallback);
}

setFieldValue(String ref, Object value){
    linker.setFieldValue(ref, value);
}

Object getFieldValue(String ref){
    return linker.getFieldValue(ref);
}
    
onEvent(String ref, String type, String callback) {
	linker.bindViewToEvent(ref, type, callback);
}

onFocus(String ref, String focusCallback, String blurCallback) {
	linker.bindFocusAndBlurEvent(ref, focusCallback, blurCallback);
}

saveArchEnt(String entity_id, String entity_type, String geo_data, List attributes) {
	return linker.saveArchEnt(entity_id, entity_type, geo_data, attributes);
}

saveRel(String rel_id, String rel_type, String geo_data, List attributes) {
	return linker.saveRel(rel_id, rel_type, geo_data, attributes);
}

addReln(String entity_id, String rel_id, String verb) {
	linker.addReln(entity_id, rel_id, verb);
}

createAttributeList() {
	return new ArrayList();
}

createEntityAttribute(String name, String text, String vocab, String measure, String certainty) {
	EntityAttribute attribute = new EntityAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	attribute.setMeasure(measure);
	attribute.setCertainty(certainty);
	return attribute;
}

createRelationshipAttribute(String name, String text, String vocab) {
	RelationshipAttribute attribute = new RelationshipAttribute();
	attribute.setName(name);
	attribute.setText(text);
	attribute.setVocab(vocab);
	return attribute;
}

populateDropDown(String ref, Collection values){
    linker.populateDropDown(ref, values);
}

populateCheckBoxGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

populateRadioGroup(String ref, Collection values) {
	linker.populateList(ref, values);
}

Object fetchArchEnt(String id){
    return linker.fetchArchEnt(id);
}

Object fetchRel(String id){
    return linker.fetchRel(id);
}

Object fetchOne(String query){
    return linker.fetchOne(query);
}

Collection fetchAll(String query){
    return linker.fetchAll(query);
}

String getListItemValue() {
	return _list_item_value;
}

goBack(){
    linker.goBack();
}

setGPSUpdateInterval(int seconds){
	linker.setGpsUpdateInterval(seconds);
}

Object getGPSPosition(){
	return linker.getGPSPosition();
}

Object getGPSEstimatedAccuracy(){
	return linker.getGPSEstimatedAccuracy();
}

Object getGPSHeading(){
	return linker.getGPSHeading();
}

Object getGPSPosition(String gps){
	return linker.getGPSPosition(gps);
}

Object getGPSEstimatedAccuracy(String gps){
	return linker.getGPSEstimatedAccuracy(gps);
}

Object getGPSHeading(String gps){
	return linker.getGPSHeading(gps);
}

showRasterMap(String ref, String filename) {
	linker.showRasterMap(ref, filename);
}

setMapFocusPoint(String ref, float latitude, float longitude) {
	linker.setMapFocusPoint(ref, latitude, longitude);
}

setMapRotation(String ref, float rotation) {
	linker.setMapRotation(ref, rotation);
}

setMapZoom(String ref, float zoom) {
	linker.setMapZoom(ref, zoom);
}

setMapTilt(String ref, float tilt) {
	linker.setMapTilt(ref, tilt);
}

showVectorLayer(String ref, String filename) {
	linker.showVectorLayer(ref, filename);
}

clearVectorLayer(String ref, int id) {
	linker.clearVectorLayer(ref, id);
}

centerOnCurrentPosition(String ref){
	linker.centerOnCurrentPosition(ref);
}
